// Generated by CoffeeScript 1.3.3
(function() {
  var EventEmitter, Pitboss, Runner, exec, fork, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = require('child_process'), fork = _ref.fork, exec = _ref.exec;

  EventEmitter = require('events').EventEmitter;

  exports.Pitboss = Pitboss = (function(_super) {

    __extends(Pitboss, _super);

    function Pitboss(code, options) {
      var _this = this;
      this.runner = new Runner(code, options);
      this.runner.on('completed', function() {
        return _this.next();
      });
      this.q = [];
    }

    Pitboss.prototype.run = function(_arg, callback) {
      var context, libraries;
      context = _arg.context, libraries = _arg.libraries;
      this.q.push({
        context: context,
        libraries: libraries,
        callback: callback
      });
      return this.next();
    };

    Pitboss.prototype.next = function() {
      var c;
      if (this.runner.running) {
        return false;
      }
      c = this.q.shift();
      if (c) {
        return this.runner.run({
          context: c.context,
          libraries: c.libraries
        }, c.callback);
      }
    };

    return Pitboss;

  })(EventEmitter);

  exports.Runner = Runner = (function(_super) {

    __extends(Runner, _super);

    function Runner(code, options) {
      var _base, _base1, _base2, _base3;
      this.code = code;
      this.options = options;
      this.memoryExceeded = __bind(this.memoryExceeded, this);

      this.timeout = __bind(this.timeout, this);

      this.failedForkHandler = __bind(this.failedForkHandler, this);

      this.messageHandler = __bind(this.messageHandler, this);

      this.options || (this.options = {});
      (_base = this.options).timeout || (_base.timeout = 500);
      (_base1 = this.options).heartBeatTick || (_base1.heartBeatTick = 100);
      (_base2 = this.options).memoryLimit || (_base2.memoryLimit = 1024 * 1024);
      (_base3 = this.options).rssizeCommand || (_base3.rssizeCommand = "ps -p PID -o rssize=");
      this.launchFork();
      this.running = false;
      this.callback = null;
    }

    Runner.prototype.launchFork = function() {
      this.proc = fork(__dirname + '/../lib/forkable.js');
      this.proc.on('message', this.messageHandler);
      this.proc.on('exit', this.failedForkHandler);
      this.rssizeCommand = this.options.rssizeCommand.replace('PID', this.proc.pid);
      return this.proc.send({
        code: this.code
      });
    };

    Runner.prototype.run = function(_arg, callback) {
      var context, id, libraries, msg;
      context = _arg.context, libraries = _arg.libraries;
      if (this.running) {
        return false;
      }
      id = Date.now().toString() + Math.floor(Math.random() * 1000);
      msg = {
        context: context,
        libraries: libraries,
        id: id
      };
      this.callback = callback || false;
      this.startTimer();
      this.running = id;
      this.proc.send(msg);
      return id;
    };

    Runner.prototype.disconnect = function() {
      if (this.proc && this.proc.connected) {
        return this.proc.disconnect();
      }
    };

    Runner.prototype.kill = function() {
      if (this.proc && this.proc.connected) {
        this.proc.kill("SIGKILL");
      }
      return this.closeTimer();
    };

    Runner.prototype.messageHandler = function(msg) {
      this.running = false;
      this.closeTimer();
      this.emit('result', msg);
      if (this.callback) {
        if (msg.error) {
          this.callback(msg.error);
        } else {
          this.callback(null, msg.result);
        }
      }
      return this.notifyCompleted();
    };

    Runner.prototype.failedForkHandler = function() {
      var error;
      this.running = false;
      this.closeTimer(this.timer);
      this.launchFork();
      error = this.currentError || "Process Failed";
      this.emit('failed', error);
      if (this.callback) {
        this.callback(error);
      }
      return this.notifyCompleted();
    };

    Runner.prototype.timeout = function() {
      this.currentError = "Timedout";
      return this.kill();
    };

    Runner.prototype.memoryExceeded = function() {
      var _this = this;
      return exec(this.rssizeCommand, function(err, stdout, stderr) {
        err = err || stderr;
        if (err) {
          console.error("Command " + _this.rssizeCommand + " failed:", err);
        }
        if ((!err) && parseInt(stdout, 10) > _this.options.memoryLimit) {
          _this.currentError = "MemoryExceeded";
          return _this.kill();
        }
      });
    };

    Runner.prototype.notifyCompleted = function() {
      return this.emit('completed');
    };

    Runner.prototype.startTimer = function() {
      this.closeTimer();
      this.timer = setTimeout(this.timeout, this.options['timeout']);
      return this.memoryTimer = setInterval(this.memoryExceeded, this.options['heartBeatTick']);
    };

    Runner.prototype.closeTimer = function() {
      if (this.timer) {
        clearTimeout(this.timer);
      }
      if (this.memoryTimer) {
        return clearInterval(this.memoryTimer);
      }
    };

    return Runner;

  })(EventEmitter);

}).call(this);
